A path traversal vulnerability allows an attacker to access files on your web server to which they should not have access. They do this by tricking either the web server or the web application running on it into returning files that exist outside of the web root folder. Another attack pattern is that users can pass in malicious Zip file which may contain directories like "../". Typical sources of this vulnerability involves obtaining information from untrusted user input through web requests, getting entry directory from Zip files. Sinks will relate to file system manipulation, such as creating file, listing directories, and etc.

Some example source/sink/taint-propagator methods are:
[
  {
    "package": "java.util.zip",
    "class": "ZipEntry",
    "method": "getName",
    "signature": "String getName()",
    "sink_args": [],
    "type": "source"
  },
  {
    "package": "java.io",
    "class": "FileInputStream",
    "method": "FileInputStream",
    "signature": "FileInputStream(File file)",
    "sink_args": [
      "file"
    ],
    "type": "sink"
  },
  {
    "package": "java.net",
    "class": "URL",
    "method": "URL",
    "signature": "URL(String url)",
    "sink_args": [],
    "type": "taint-propagator"
  },
  {
    "package": "java.io",
    "class": "File",
    "method": "File",
    "signature": "File(String path)",
    "sink_args": [],
    "type": "taint-propagator"
  }
]

Among the following methods, assuming that the arguments passed to the given function is malicious, what are the functions that are potential source, sink, or taint-propagators to Path Traversal or Zip Slip attack (CWE-022)?

Package,Class,Method,Signature
java.util.concurrent,TimeUnit,toMillis,long toMillis(long p0)
java.util.concurrent.atomic,AtomicBoolean,AtomicBoolean,AtomicBoolean(boolean p0)
java.util.concurrent.atomic,AtomicBoolean,get,boolean get()
java.util.concurrent.atomic,AtomicBoolean,set,void set(boolean p0)
java.util.function,Consumer,accept,void accept(Exception p0)
java.util.regex,Matcher,end,int end()
java.util.regex,Matcher,find,boolean find()
java.util.regex,Matcher,group,String group()
java.util.regex,Pattern,compile,Pattern compile(String p0)
java.util.regex,Pattern,matcher,Matcher matcher(CharSequence p0)
java.util.stream,Collectors,joining,Collector<CharSequence,?,String> joining(CharSequence p0)
java.util.stream,Stream,anyMatch,boolean anyMatch(Predicate<? super String> p0)
java.util.stream,Stream,collect,R collect(Collector<? super String,A,R> p0)
java.util.zip,GZIPInputStream,GZIPInputStream,GZIPInputStream(InputStream p0)
java.util.zip,GZIPOutputStream,GZIPOutputStream,GZIPOutputStream(OutputStream p0, boolean p1)
javax.net.ssl,SSLContext,getInstance,SSLContext getInstance(String p0)
javax.net.ssl,SSLContext,getSocketFactory,SSLSocketFactory getSocketFactory()
javax.net.ssl,SSLContext,init,void init(KeyManager[] p0, TrustManager[] p1, SecureRandom p2)
javax.net.ssl,TrustManagerFactory,getDefaultAlgorithm,String getDefaultAlgorithm()
javax.net.ssl,TrustManagerFactory,getInstance,TrustManagerFactory getInstance(String p0)
javax.net.ssl,TrustManagerFactory,getTrustManagers,TrustManager[] getTrustManagers()
javax.net.ssl,TrustManagerFactory,init,void init(KeyStore p0)
javax.servlet,Filter,doFilter,void doFilter(ServletRequest p0, ServletResponse p1, FilterChain p2)
javax.servlet,FilterChain,doFilter,void doFilter(ServletRequest p0, ServletResponse p1)
javax.servlet,FilterConfig,getFilterName,String getFilterName()
javax.servlet,FilterConfig,getInitParameter,String getInitParameter(String p0)
javax.servlet,FilterConfig,getInitParameterNames,Enumeration<String> getInitParameterNames()
javax.servlet,FilterConfig,getServletContext,ServletContext getServletContext()
javax.servlet,ServletContext,getAttribute,Object getAttribute(String p0)
javax.servlet,ServletException,ServletException,ServletException(String p0)

